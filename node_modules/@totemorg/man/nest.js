/**
Reduce program control-blocks using a language model defaulting to:


	if TEST
		DO
	elseif TEST
		DO
	:
	else
		DO
	end
	
	switch TEST
		case TEST
			DO
		:
		default TEST
			DO
	end
	
	try
		DO
	catch
		DO
	end
	
	for|while|until|when|def TEST|INDEX|EVENT|ARGS
		DO
	end
	
Inline functions are also supported using fat-arrows:

	(x,y,...) => {
		DO
	}

@param {String|Array} pgm Program being parsed.  Use Array to bypass default eol-tokenization.
@param {Array} blks Stash fo code blocks; initially [].
@param {Number} idx Current line index to start parsing; initially 0. 
@param {Object} lang Language model; see code herein.

@example

nest(`
a1="this;is;a;test";
cos( 1, ;(u,x) => {
	u+v;
}, ;def f=(x,y)
	f=x+y;
end
)
for i
	i1
	i2
	for j
		j1; j2;
		while u; u1;end
	end
end
a2;
if u
	u1
	u2
elseif v
	v1
	v2
else
	x
end
a4
`);

returns the block-reduced code: 

	a1=$ctx[0]\n' +
    'cos( 1, \n' +
    'def($ctx,[1]), def($ctx,[2]))\n' +
    'for($ctx,[5])a2\n' +
    'if($ctx,[6,7,8])a4\n
	
and its associated code blocks:

	[
	  'this;is;a;test',
	  { test: '(u,x)', code: 'u+v\n' },
	  { test: 'f=(x,y)', code: 'f=x+y\n' },
	  { test: 'u', code: ' u1\n' },
	  { test: 'j', code: 'j1\n j2\nwhile($ctx,[3])' },
	  { test: 'i', code: 'i1\ni2\nfor($ctx,[4])' },
	  { test: 'u', code: 'u1\nu2\n' },
	  { test: 'v', code: 'v1\nv2\n' },
	  { test: null, code: 'x\n' }
	]


*/

function nest( pgm, blks, idx, lang ) {
	
	if ( !lang )	// default the language model 
		return nest( pgm, blks||[], idx||0, {
			opens: /^(for|while|if|try|switch|when|until|def) (.*)/,
			terms: /^(end|case|elseif|else|catch|default|\})/,
			close: {
				case: "switch", elseif: "if", else: "if", catch: "try", default: "switch"
			},
			quote: /"(.*)"/g,
			indef: /(.*) => \{$/,
			eol: ";",
			newl: "\n"
		});
	
	const
		{opens,terms,indef,close,quote,eol,newl} = lang;
		 
	var
		 code = "";
	 
	if ( !pgm.forEach )		// clean and split the program into lines
		 pgm = pgm
		 		.replace( /\t/g, "")
		 		.replace( /\n/g, eol)
		 		.replace( quote, (x,str) => {
			 		blks.push( str );
			 		return `$ctx[${blks.length-1}]`;
		 		})
		 		.split(eol);

	for ( var line = pgm[idx]; line !== undefined ; idx++, line=pgm[idx] ) {	// enumerate thru each program line
		if ( ctrl = line.match( indef ) ) {			// start inline def
			var
				[x,arg] = ctrl,
				args = [blks.length],
				op = "def",
				[xcode,xidx] = nest(pgm, blks, idx+1),
				line = pgm[xidx].substr(1);
			
			//console.log("indef", [arg,xcode,line]);
			
			blks.push({ test: arg || null, code: xcode });
			code += `${op}($ctx,[${args.join()}])${line}`;
			idx = xidx;
		}
		
		else
		if ( ctrl = line.match( opens ) ) {			// start an open block
			var
		 		[x,op,arg] = ctrl,
		 		args = [];
		 
			//console.log( line, ctrl, op,arg);
			
		 	do {									// process all valid terminators
		 		var
		 			[xcode,xidx] = nest( pgm, blks, idx+1 ),
		 			line = pgm[xidx],
		 			[term,xarg] = line.split(" ");
		 		
		 		args.push( blks.length );
		 		blks.push({ test: arg || null, code: xcode });

				idx = xidx;
				arg = xarg;
		
				//console.log("arg", [op, term]);
			}
			
		 	while (close[term] == op);
		 
		 	if (term == "end") {			// terminator closes
				//console.log("end", [op,args,idx]);
				code += `${op}($ctx,[${args.join()}])`;
			}

			else 							// terminator does not properly close
				return [ `invalid terminator "${term}"` , -1 ];
		}
	
		else
		if ( ctrl = line.match( terms ) ) 			// line terminates a block
			return [code, idx];
	
		else
		if ( line )									// ignore empty line
			code += line + newl;	
	}

	return [ code, idx ];
}

console.log( nest(`
a1="this;is;a;test";
cos( 1, ;(u,x) => {
	u+v;
}, ;def f=(x,y)
	f=x+y;
end
)
for i
	i1
	i2
	for j
		j1; j2;
		while u; u1;end
	end
end
a2;
if u
	u1
	u2
elseif v
	v1
	v2
else
	x
end
a4
`, blks=[], 0), blks);

