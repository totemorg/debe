!function(e, r) {
  "object" == typeof exports && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define([ "exports" ], r) : r((e = "undefined" != typeof globalThis ? globalThis : e || self).CrlfNormalize = {});
}(this, (function(e) {
  "use strict";
  var r;
  e.EnumLineBreak = void 0, (r = e.EnumLineBreak || (e.EnumLineBreak = {})).CR = "\r", 
  r.CRLF = "\r\n", r.LF = "\n";
  const n = /\r\n|\r(?!\n)|\n/g, t = new RegExp(`(${n.source})`, n.flags);
  function crlf(e, r = "\n") {
    return e.replace(n, r);
  }
  function chkcrlf(e, r) {
    var n;
    const t = null !== (n = null == r ? void 0 : r.disable) && void 0 !== n ? n : {};
    return {
      lf: !t.lf && /\n/.test(e.replace(/\r\n/g, "")),
      crlf: !t.crlf && /\r\n/.test(e),
      cr: !t.cr && /\r(?!\n)/.test(e)
    };
  }
  function _detectLineBreakCore(e) {
    return e.crlf ? "\r\n" : e.lf || !e.cr ? "\n" : "\r";
  }
  e.CR = "\r", e.CRLF = "\r\n", e.LF = "\n", e.R_CRLF = n, e.R_CRLF_MATCH = t, e._detectLineBreakCore = _detectLineBreakCore, 
  e.chkcrlf = chkcrlf, e.crlf = crlf, e.crlf_unicode_normalize = function crlf_unicode_normalize(e, r = "\n") {
    const n = r + r;
    return e.replace(/\u000C/g, r + r + r).replace(/\u2028/g, r).replace(/\u2029/g, n);
  }, e.default = crlf, e.detectLineBreak = function detectLineBreak(e, r) {
    return _detectLineBreakCore(chkcrlf(e, r));
  }, e.isCR = function isCR(e) {
    return "\r" === e;
  }, e.isCRLF = function isCRLF(e) {
    return "\r\n" === e;
  }, e.isEqualWithIgnoreLineSeparators = function isEqualWithIgnoreLineSeparators(e, r) {
    const n = chkcrlf(e), t = chkcrlf(r);
    let c = !1;
    return n.cr === t.cr && n.crlf === t.crlf && n.lf === t.lf && (c = crlf(e) === crlf(r)), 
    {
      bool: c,
      _lb_a: n,
      _lb_b: t
    };
  }, e.isLF = function isLF(e) {
    return "\n" === e;
  }, e.lineSplit = function lineSplit(e) {
    return e.split(n);
  }, e.nameToLineBreak = function nameToLineBreak(e) {
    switch (null == e ? void 0 : e.toUpperCase()) {
     case "LF":
      return "\n";

     case "CR":
      return "\r";

     case "CRLF":
      return "\r\n";
    }
    throw new TypeError(`Invalid line break name: ${e}`);
  }, e.toLineBreakName = function toLineBreakName(e) {
    switch (e) {
     case "\n":
      return "LF";

     case "\r":
      return "CR";

     case "\r\n":
      return "CRLF";
    }
    throw new TypeError("Invalid line break");
  }, Object.defineProperty(e, "__esModule", {
    value: !0
  });
}));
//# sourceMappingURL=index.umd.production.min.cjs.map
