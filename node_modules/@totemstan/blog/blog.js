// UNCLASSIFIED

/**
Converts [TOTEM markdown](/api.view) to html.  This module 
documented in accordance with [jsdoc]{@link https://jsdoc.app/}.

@module BLOG

@requires [enums](https://github.com/totemstan/enums)
@requires [mathjax-node](https://www.npmjs.com/package/mathjax-node)
*/

const 
	// { licenseCode } = require("flex"),
	ENV = process.env,
	JAX = require("mathjax-node"),  //< server-side mathjax parser
	{ Copy, Fetch, Log, Start } = require("@totemstan/enums");

const { Trace } = BLOG = module.exports = {
	/*
	doc: ( obj , idx ) => {
		var doc = {};

		if ( keys = idx ? idx.split(",") : null ) 
			keys.forEach( key => { 
				if ( key in obj ) doc[key] = obj[key];
			});

		else
			doc = obj;

		return (JSON.stringify(doc) || "").replace(/ /g,"").replace(/_/g,"").replace(/^/g,"");
	},  */

	Trace: (msg, ...args) => `blog>>>${msg}`.trace( args ),

	config: opts => {
		if (opts) Copy(opts,BLOG,".");
		return BLOG;
	},
	
	/**
	Precision to show values in [JSON || #DOC || TEX] OP= [JSON || #DOC || TEX] expansions
	*/
	
	digits: 4,  // precision to show values in [JSON || #DOC || TEX] OP= [JSON || #DOC || TEX] expansions

	/**
	TeX substitutions.
	*/
	
	subs: {
		alpha: "\\alpha",
		beta: "\\beta",
		gamma: "\\gamma",
		delta: "\\delta",
		eps: "\\epsilon",
		mu: "\\mu",
		lambda: "\\lambda",
		sigma: "\\sigma",
		nu: "\\nu",
		eta: "\\eta",
		xi: "\\xi",
		omega: "\\omega"
	},
		
	/**
	Expands LHS := RHS TeX patterns using toEqn
	@returns {string}
	@param {string} lhs 
	@param {string} rhs
	@param {object} ctx
	*/
	":=" : (lhs,rhs,ctx) => ctx.toEqn( "", lhs, rhs, ctx), 		// inline TeX

	/*
	"|=" : (lhs,rhs,ctx) => ctx.toEqn("a", lhs,rhs,ctx),		// Ascii Match
	";=" : (lhs,rhs,ctx) => ctx.toEqn("n", lhs,rhs,ctx),		// break TeX
	">=": (lhs,rhs,ctx) => ctx.toTag(lhs,rhs,ctx),			// [post](url) 
	"<=": (lhs,rhs,ctx) => {												// add context value or generator

		if ( rhs.split(",").length > 1) {
			eval(`
try {
ctx[lhs] = (lhs,rhs,ctx) => ctx.toTag( ${rhs} );
}
catch (err) {
} `);
		}

		else
			ctx[lhs] = rhs.parse$( ctx );

		return ""; 
	},  */

	/**
	Expands [JSON || #DOC || TEX] OP= [JSON || #DOC || TEX] TeX patterns
	@returns {string}
	@param {string} pre prefix
	@param {string} lhs lhs of pattern
	@param {string} rhs rhs of pattern
	@param {object} ctx blogging context
	*/
	toEqn: (pre,lhs,rhs,ctx) => {		// expand [JSON || #DOC || TEX] OP= [JSON || #DOC || TEX] 

		function toTeX(val)  {
			const {digits,subs} = ctx;

			if (val)
				switch (val.constructor.name) {
					case "Number": 
						return val.toPrecision(digits);

					case "String": 
						return val;	

					case "Array": 
						var mat = val[0] || 0;
						
						if ( mat.forEach ) {
							val.forEach( (vec,idx) => {
								vec.forEach( (arg,idx) => vec[idx] = toTeX(arg) );
								val[idx] = vec.join("&");
							});
							return "\\left[ \\begin{matrix} " + val.join(" \\\\ ") + " \\end{matrix} \\right]";
						}
						
						else {
							val.forEach( (rec,idx) => val[idx] = toTeX(rec) );
							return  "\\left[ \\begin{matrix} " + val.join(",") + " \\end{matrix} \\right]";
						}

					case "Date": 
						return val+"";

					case "Object": 
						var rtns = [];
						for (var key in val) 
							rtns.push( "{" + toTeX(val[key]) + "}_{" + (subs[key] || key) + "}" );

						return [
							"\\left\\{ \\begin{matrix} ",
							rtns.join( "\\\\ " ),
							" \\end{matrix} \\right\\}"
						].join("");

					default: 
						return JSON.stringify(val);
				}

			else 
				return (val == 0) ? "0" : "\\emptyset";
		}

		function toDoc (arg) {
			const 
				keys = arg.split("#"),
				key = keys[0],
				val = key ? key.parseJS(ctx) : null;
				
//Log(">>>>>>>todoc", arg,keys,val);
			if ( val ) 
				if ( keys.length > 1 ) {
					var rtn = {};
					keys.forEach( (key,idx) => {
						if ( idx ) 
							rtn[key] = val[ key ];
					});
					return rtn;
				}
			
				else
					return val;
			
			else 
				return arg.substr(1).parseJS(ctx);
			/*
			switch ( arg.charAt(0) ) {
				case "#":
					arg = arg.substr(1);
					switch (2) {
						case 0:
							return arg.parseJS(ctx);
							
						case 1:
							var args = [];
							arg.split(",").forEach( arg => args.push(arg.parseJS(ctx)) );
							return args.join(" , ");
							
						case 2:
							var
								keys = arg.split(","),
								arg = keys[0].parseJS(ctx);
							
							Log(">>>arg", arg,keys);
							return arg;
					}

				default:
					var args = arg.split(",");
					return (args.length>1) ? args : arg;
			}*/
		} 

		//Log(">>>eqn", lhs, rhs);
		return pre + "$$ " + toTeX(lhs) + " = " + toTeX(rhs.parseJSON(toDoc)) + " $$";
	},

	toTag: (lhs,rhs,ctx) => {
		var
			lKeys = lhs.split(","),
			rKeys = rhs.split(","),
			base = lKeys[0] + "$.",
			skin = rKeys[0],
			args = (rKeys[3] || "").replace(/;/g,","),
			opts = {
				w: rKeys[1],
				h: rKeys[2],
				x: lKeys[1] ? base + lKeys[1] : "",
				y: lKeys[2] ? base + lKeys[2] : "",
				r: lKeys[3] ? base + lKeys[3] : ""
			};

		for (var key in opts) if ( !opts[key] ) delete opts[key];

		//Log( base, view, "[post](/" + (skin+".view").tag("?",opts)+args + ")" );
		return "[post](/" + `${skin}.view`.tag("?",opts)+args + ")";
	}
};

/**
Short form of blogify.

@param {Object} ctx initial blogging context
@param {Function} cb callback accepting the resulting html
*/
function blog(ctx, cb) {
	this.blogify("",  {}, ctx, cb);
}

/**
Expands markdown:

	$ VIEW { SRC ? w=WIDTH & h=HEIGHT & x=KEY$INDEX & y=KEY$INDEX ... }  
	$ { JS }   
	[ LINK ] ( URL )  
	$ $ inline TeX $ $ || n$ $ break TeX $ $ || a$ $ AsciiMath $ $ || m$ $ MathML $ $
	TeX := TeX || #VAR || VAR#KEY#KEY...
	# SECTION  
	ESCAPE || $with || $for || $if:\\n \\t BLOCK \\n

to html.

@param {Object} ctx initial blogging context
@param {String} src default source path
@param {Object} rec source record
@param {Function} cb callback accepting the resulting html
*/
function blogify(src, ctx, rec, cb) {

	Copy(BLOG, ctx);

	//Log(">>>blog", ctx, src, rec,"src>>>>",this+"");
	//Log(">>>blog", this);
	//Log("blog rec", rec);
	
	/*
	ctx.ab = args => {		// add key abbrevators
		if ( args)
			switch (args.constructor.name) {
				case "Array":
					args.forEach( (arg,idx) => ctx[ `_${idx}` ] = arg );
					break;

				case "Object":
					Each(args, (idx,arg) => ctx[ `_${idx}` ] = arg );
					break;

				case "String":
					ctx.ab( ctx[ `Save_${args}` ] );
			}		

		return "";
	};  */
	//Log(">>>>blogify", this, src);

	// ctx.$ = $; 	// add $man array functions

	for (var key in rec)  { // parse and abbreviate json stores
		try { 
			ctx[key] = JSON.parse( rec[key] ); 
		} 
		
		catch (err) { 
			ctx[key] = rec[key]; 
		}

		if ( key.startsWith("Save_") ) // abbreviate
			ctx[ key.substr(4) ] = ctx[key];
	}

	this
	.replace(/<!--.*-->/g, "")
	.replace(/^! /gm, str => "\t")
	.replace(/^!!/gm, str => "\n")
	.Xescape( [], ctx, (html,blocks) => // escape code blocks
	html.Xbreaks( html => // force new lines
	html.Xgrid( html => // expand grids
	html.Xsection( html => // expand section headers
	html.Xkeys( ctx, html => // expand js keys
	html.Xoper(ctx, html => // expand operators
	html.Xtex( html => // expand TeX
	html.Xlink( html => // expand links
	html.Xembed( html => 	// expand embeds
	html.Xview( src, ctx, html => 	// expand embeds
	html.Xfollow( src, ctx, html => // spoof href links
	html.Xbacksub( blocks, html => cb(html) // backsub code blocks
	))))))))))));
}
	
[  // string prototypes
	blog,
	blogify,
	
	function Xbreaks( cb ) {	// expand hard line breaks
		cb( this.replace( /  \n/g, "<br>" ) );
	},
	
	/*
	function Xescape( blocks, ctx, cb ) { // callback cb(blocks, escaped blocks)
		var 
			key = "@esc",
			fetchBlock = function ( rec, cb ) {	// callsback cb with block placeholder
				//Log(`block[${blocks.length}] `, rec.arg1 );
				var 
					debug = false,
					stmt = rec.arg1 || "",
					block = rec.arg2 || "",
					stmt = stmt.replace(/^\$(.*) (.*)/, (str,op,src) => {	// replace enumerators
						
						//Log(">>esc", op,src);
						
						if ( Src = src.parseJS(ctx) ) {	// valid enumerator var provided
							var 
								rtn = "",
								N = Src.forEach ? Src.length : Object.keys(Src).length;
							
							ctx._a = src;
							ctx._n = N;
							//Log(">>>",op,src,block);
						
							switch (op) {	// treat enumerator
								case "with":
									blocks.push( Src );
									cb( "@block" );
									/ *block = ctx.interface();
									Log(">>>if", block);
									blocks.push( block );
									cb( "@block" );	* /
									break;
									
								case "for":
								case "enum":
								case "each":
									if ( Src.forEach )
										for ( ctx._i=0; ctx._i<N; ctx._i++ ) 
											rtn += block.parse$(ctx)+" ";
									
									else
									if ( Src.length )
										rtn += block.parse$(ctx)+" ";
									
									else
										for ( ctx._i in Src ) 
											rtn += block.parse$(ctx)+" ";
									
									cb( rtn );
									break;

								case "skip":
								case "nada":
								case "//":
								case "comment":
									cb("");
									break;
									
								case "trace":
								case "dump":
								case "debug":
									cb("?"+op);
									break;
									
								case "if":
									cb( block.parse$(ctx)+" " );
									break;
									
								case "do":
								case "until":
								default:
									cb("?"+op);
									break;
							}
						}
						
						else
							cb( "" )
							
						return "$";
					});

				//Log(">>escape",block, stmt);
				if ( stmt != "$" ) {
					blocks.push( block );
					cb( stmt + ":" + "@block" );
				}
			},
			pattern = /(.*)\:\n((\t.*\n)+)\n/gm;
		
		//Log("Xescape", this.match( pattern ) );
		this.serialize( fetchBlock, pattern, key, html => cb( html, blocks) ); 		
	},  */
	
	function Xgrid( cb ) {
		cb( this.replace(/\n((\n\|.*)+)\n/gm, (str,guts) => {
			//console.log("grid>>>>", [guts]); 
			const 
				rows = guts.split("\n"),
				keys = rows[1].split("|"),
				just = [""],
				grid = [];
			
			rows.forEach( (row,n) => { 
				if ( n == 2 ) 
					row.split("|").forEach( (val,m) => {
						if ( m ) {
							if ( val.startsWith(":") && val.endsWith(":") ) just.push("C");
							else
							if ( val.startsWith(":") ) just.push("L");
							else
							if ( val.endsWith(":") ) just.push("R");
							else
								just.push("C");
						}
					});
					
				else
				if ( n > 2 ) {
					const rec = {};
					row.split("|").forEach( (val,m) => {
						if ( m ) rec[keys[m]] = val;
					});
					grid.push(rec);
				}
			});
			
			//console.log(just, grid);
			return grid.gridify(false);
		}) );
	},
	
	function Xescape( blocks, ctx, cb ) { // callback cb(blocks, escaped blocks)
		cb( this.replace( /(.*)\:\n((\t.*\n)+)\n/gm , (str,stmt,block) => {
			//Log("escape", stmt, block);
			
			var 
				debug = false,
				stmt = stmt.replace(/^\$(.*) (.*)/, (str,op,src) => {	// replace enumerators

					//Log(">>esc", op,src);

					if ( Src = src.parseJS(ctx) ) {	// valid enumerator var provided
						var 
							rtn = "",
							N = Src.forEach ? Src.length : Object.keys(Src).length;

						ctx._a = src;
						ctx._n = N;
						//Log(">>>",op,src,block);

						switch (op) {	// treat enumerator
							case "with":
								blocks.push( Src );
								cb( "@block" );
								/*block = ctx.interface();
								Log(">>>if", block);
								blocks.push( block );
								cb( "@block" );	*/
								break;

							case "for":
							case "enum":
							case "each":
								if ( Src.forEach )
									for ( ctx._i=0; ctx._i<N; ctx._i++ ) 
										rtn += block.parse$(ctx)+" ";

								else
								if ( Src.length )
									rtn += block.parse$(ctx)+" ";

								else
									for ( ctx._i in Src ) 
										rtn += block.parse$(ctx)+" ";

								cb( rtn );
								break;

							case "skip":
							case "nada":
							case "//":
							case "comment":
								cb("");
								break;

							case "trace":
							case "dump":
							case "debug":
								cb("?"+op);
								break;

							case "if":
								cb( block.parse$(ctx)+" " );
								break;

							case "do":
							case "until":
							default:
								cb("?"+op);
								break;
						}
					}

					else
						cb( "" )

					return "$";
				});

			//Log("escaped", stmt, block);
			if ( stmt != "$" ) {	// not a control statement
				blocks.push( block );
				return stmt + ":" + "@block";
			}
			
			else
				return "";

			//Log("escape blocks", blocks);
			
		}), blocks );
	},
	
	function Xdummy(cb) {  // for debugging with callback(this)
		cb(this);
	},
	
	/*
	function Xlink( cb ) {  // expand [NAME](LINK)
		var 
			key = "@link",
			fetch = function ( rec, cb ) {  // expand markdown
				var
					url = rec.arg2,
					opt = rec.arg1 || url ;

				cb( opt.link( url ) );
			},
			pattern = /\[([^\[\]]*)\]\(([^\)]*)\)/g ;
		
		// Log("Xlink", this.match(pattern));
		this.serialize( fetch, pattern, key, html => cb(html) ); 
	}, */
	
	function Xlink( cb ) {  // expand [NAME](LINK)
		cb( this.replace( /\[([^\[\]]*)\]\(([^\)]*)\)/g, (str,lab,url) => lab.link(url) ) );
	},
	
	/*
	function Xtopic( req, cb ) {	// callback with tag{TOPIC} markdown
		var 
			key = "@top",
			fetch = function ( rec, cb ) {  // expanded markdown
				var 
					secret = "",
					topic = rec.topic,
					product = topic+".html";

				if (req)		// content tracking enabled
					if ( licenseCode )
						licenseCode( req.sql, html, {  // register this html with the client
							_Partner: req.client,
							_EndService: "",  // leave empty so lincersor wont validate by connecting to service
							_Published: new Date(),
							_Product: product,
							Path: "/tag/"+product
						}, (pub, sql) => {
							if (pub) {
								cb( `${rec.topic}=>${req.client}`.tag( "/tags.view" ) );
								sql.query("INSERT INTO app.tags SET ? ON DUPLICATE KEY UPDATE Views=Views+1", {
									Viewed: pub._Published,
									Target: pub._Partner,
									Topic: topic,
									License: pub._License,
									Message: "get view".tag( "/decode.html".tag("?",{Target:pub._Partner,License:pub._License,Topic:topic}))
								});
							}
						});
				
					else
						Trace( "NO LICENSOR", req );
				
				else	// content tracking disabled
					cb( "" );
			},	
			pattern =  /tag\{(.*)\}/g;  // /\~\{([^\}]*)\}/g;
			
		this.serialize( fetch, pattern, key, html => cb(html) ); 
	},*/
	
	/*
	function Xembed( src, ctx, cb ) {	// expand $EMBED{QUERY}
		var 
			key = "@embed",
			
			Xfetch = function ( rec, cb ) {  // expand markdown
				var
					view = rec.arg1,
					url = rec.arg2,
					keys = {src:src},
					isRef = url.charAt(0) == "$",
					[path] = (isRef ? ctx[url.substr(1)] : url).parsePath(keys,{},{},{}),
					w = keys.w || 200,
					h = keys.h || 200;
				
				Log(">>embed", [view, keys, url, path]);
						
				switch (view) {
					case "image":
					case "img":
						cb( "".tag("img",{href:path,width:w,height:w}) );
						break;
						
					case "embed":
						Log(">>>embed host=",url);
						Fetch( url, res => {
							//Log(">>>embed", res);
							cb(res);
						});
						break;
						
					default:
						//Log( "".tag("iframe", { src: `/${view}.view`.tag( "?", keys ), width:w, height:h }) );
						
						if ( path )
							cb( path.tag( "a", {href: `${view}.view`.tag( "?", keys )}) );
						
						else
							cb( "".tag("iframe", { src: `${view}.view`.tag( "?", keys ), width:w*1.1, height:h*1.1 }) );
				}
			},
			
			pattern = /\$(\w+){(.*)}/g; 
		
		//Log("Xembed", this.match( pattern ) );
		
		this.serialize( Xfetch, pattern, key, html => cb(html) ); 
	}, */
	
	function Xview( src, ctx, cb ) {	// expand $VIEW{QUERY}
		cb( this.replace( /\$(\w+){(.*)}/g, (str,view,url) => {

			const
				keys = {src:src},
				isRef = url.charAt(0) == "$",
				[path] = (isRef ? ctx[url.substr(1)] : url).parsePath(keys,{},{},{}),
				w = keys.w || 200,
				h = keys.h || 200;

			// Log("view", view, keys, url, path);

			switch (view) {
				case "image":
				case "img":
					return "".tag("img",{href:path,width:w,height:w});
					break;

				default:
					//Log( "".tag("iframe", { src: `/${view}.view`.tag( "?", keys ), width:w, height:h }) );

					if ( false )
						return path.tag( "a", {href: `/${view}.view`.tag( "?", keys )}) ;

					else {
						// Log( "".tag("iframe", { src: `/${view}.view`.tag( "?", keys ), width:w*1.1, height:h*1.1 }) );
						return "".tag("iframe", { src: `/${view}.view`.tag( "?", keys ), width:w*1.1, height:h*1.1 }) ;
					}
			}				

		}) );
	},
	
	function Xembed( res ) {	// expand $embed{QUERY}
		this.replaceSync( /\$embed{(.*)}/g, (args,cb) => {  
			
			if (cb) {
				const
					[str,url] = args;
				
				//Log("embed", url);
				
				if ( false )
					Fetch( url, res => {	// cant embed all this html
						//Log(">>>embed", res);
						cb(res);
					});
				
				else
					cb( "".tag("iframe",{src:url,width:500,height:200}) );
			}
			
			else
				res(args);
					
		});
	},

	/*
	function Xiframe( ds, cb ) {	// expand <iframe></iframe>
		var 
			key = "@frame",
			
			fetch = function ( rec, cb ) {  // expand markdown
				Fetch(rec.arg1, cb);
			},
			
			pattern = /<iframe src=["|'](.*?)["|'](.*)<\/iframe>/g;
		
		//Log("Xiframe", this.match( pattern ) );
		
		this.serialize( fetch, pattern, key, html => cb(html) ); 
	}, 
	*/
	
	function Xblog( ctx, cb ) {	// expand <blog>BLOG</blog>
		var 
			key = "@blog",
			
			fetch = function ( rec, cb ) {  // expand markdown
				rec.arg1.blogify("",ctx, {}, cb);
			},
			
			pattern = /<blog>((.|\n)*)<\/blog>/g;
		
		//Log(">>>>xblog", this);
		
		this.serial( fetch, pattern, key, html => cb(html) ); 
	},
	
	/*
	function Xblog(ctx,cb) {
		this.Xkeys(ctx, html => html.Xembed("",ctx,cb));
	}, */
		
	function Xfollow( ds, ctx, cb ) { // expand <a>NAME</a>
		if ( true ) 
			cb (this );
		else
			cb( this.replace( /href=['|"]([^'"]*)/g, (str,ref) => { // smart links to follow
				var 
					key = ctx[ref] || ref;

				//Log(">>>>>>>>>>href", ref, key);
				if ( ds )	// blogging via browser
					return `href="javascript:navigator.follow(${key},BASE.user.client,BASE.user.source)">`;

				else
					return `href="${key}"`;
			}) );
	},

	function Xbacksub( blocks, cb ) {	// backsub escaped blocks	
		var blockidx = 0;
		
		//Log(">>xback", this);
		cb( 
			this.replace(/@block/g, str => {  	
				//Log(`unblock[${blockidx}]`, blocks[blockidx]);
				return blocks[ blockidx++ ].tag("code",{}).tag("pre",{});
			}) 
		);
	},	

	function Xscript( ctx, cb ) {  // callback with vmctx, expanded scripts
		var 
			script = "",
			pattern = /script:\n((.|\n)*)/g,  // defines MARKDOWN\nscript:\SCRIPT tag pattern
			run = this.replace( pattern , (str, xscript) => {
				script = xscript;
				return "";
			});
		
		if ( script )
			try {
				$( script, ctx, (vmctx) => {
					cb( vmctx , run);
				});
			}
			catch (err) {
				cb( ctx, err+"");
			}
		
		else 
			cb(ctx, run);
	},
		
	function Xkeys( ctx, cb ) {  // expand ${key}
		//Log("xkeys", this.parse$(ctx) );
		cb( this.parse$(ctx) );
	},
	
	function Xoper( ctx, cb ) {  // expand LHS := RHS

		var 
			pattern = /(\S*) := (\S*)/g;  
		
		cb( this.replace(pattern, (str,lhs,rhs) => {
			//Log([":=", lhs, rhs]);
			if ( blogOp = ctx[":="] ) 
				return blogOp(lhs,rhs,ctx);
			else
				return "?";
		}) );
	},
	
	/*
	function Xtex( cb ) {  // expand X$$ MATH $$
		var 
			key = "@tex",
			fetch = function ( rec, cb ) {	// callsback cb with expanded TeX tag
				//Log("math",rec);
				switch (rec.arg1) {
					case "n":
						JAX.typeset({
							math: rec.arg2,
							format: "TeX",  
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case "a":
						JAX.typeset({
							math: rec.arg2,
							format: "AsciiMath",
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case "m":
						JAX.typeset({
							math: rec.arg2,
							format: "MathML", 
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case " ":
					default:
						JAX.typeset({
							math: rec.arg2,
							format: "inline-TeX",  
							//html: true,
							mml: true
						}, d => cb( " " + d.mml || "" ) );
				}
			},
			pattern = /(.?)\$\$ ([^\$]*) \$\$/g;
			
		this.serialize( fetch, pattern, key, html => cb(html) ); 
	}, */
	
	/*
	function Xtex( res ) {  // expand X$$ MATH $$
		this.replaceSync( /(.?)\$\$ ([^\$]*) \$\$/g, (args,cb) => {

			//Log("tex", args, cb?true:false);
			
			if ( cb ) {
				const [ str, op, math ] = args;
				Log("tex", op, math);
				switch ( op ) {
					case "n":
						JAX.typeset({
							math: math,
							format: "TeX",  
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case "a":
						JAX.typeset({
							math: math,
							format: "AsciiMath",
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case "m":
						JAX.typeset({
							math: math,
							format: "MathML", 
							//html: true,
							mml: true
						}, d => cb( d.mml || "" ) );
						break;
					case " ":
					default:
						JAX.typeset({
							math: math,
							format: "inline-TeX",  
							//html: true,
							mml: true
						}, d => cb( " " + d.mml || "" ) );
				}
			}

			else
				res(args);

		});
	},  */
	
	function Xtex( cb ) {  // expand X$$ MATH $$
		cb( this.replace( /(.?)\$\$ ([^\$]*) \$\$/g, (str,op,math) => {

			var rtn = "";
			
			//Log("tex", op, math);
			switch ( op ) {
				case "n":
					JAX.typeset({
						math: math,
						format: "TeX",  
						//html: true,
						mml: true
					}, d => rtn = d.mml );
					break;
				case "a":
					JAX.typeset({
						math: math,
						format: "AsciiMath",
						//html: true,
						mml: true
					}, d => rtn = d.mml );
					break;
				case "m":
					JAX.typeset({
						math: math,
						format: "MathML", 
						//html: true,
						mml: true
					}, d => rtn = d.mml );
					break;
				case " ":
				default:
					JAX.typeset({
						math: math,
						format: "inline-TeX",  
						//html: true,
						mml: true
					}, d => rtn = " " + d.mml );
			}

			//Log("tex", rtn);
			return rtn;
		}) );
	},
	
	function Xparms( goto, cb ) {		// expand <!---parms KEY=VAL&...--->
		var
			pattern = /<!---parms ([^>]*)?--->/g;
		
		cb( this.replace(pattern, (str, parms) => {
					
			//Log(">>>Xparms", parms);
			
			var 
				inputs = [],
				keys = [];

			parms.split("&").forEach( (parm) => {  // each collect parm (key=value) needs an input
				parm.replace(/([^=]*)?=(.*)?/, (str, key, val) => {		// key=value
					inputs.push( `${key}: <input id="parms.${key}" type="text" value="${val}" autofocus >` );
					keys.push( '"' + key + '"' );
					return "";
				});
				return "";
			});

			// this litle marvel submits all inputs to the goto service
			return `
<script>
	String.prototype.tag = ${"".tag}
	function submitForm() {
		var parms = {};
		[${keys}].forEach( (key) => parms[key] = document.getElementById("parms."+key).value );

		window.open( "/${goto}".tag("?", parms) );
	}
</script>
<form onsubmit="submitForm()">
	${inputs.join("")}
	<button id="parms.submit" type="submit" value="submit">submit</button>
</form>` ;

		}) );
	},
	
	function XFetch( cb ) {  // expand <!---fetch URL--->
		var 
			key = "@fetch",
			fetch = function ( rec, cb ) {  // callsback cb with expanded fetch-tag 
				//Log(">>>>Xfetch", rec.arg1);
				Fetch( rec.arg1, cb );
			},
			pattern = /<!---fetch ([^>]*)?--->/g;
			
		this.serial( fetch, pattern, key, html => cb(html) );
	},

	function Xsection( cb ) { // expand #.... SECTION
		var
			key = "@sec",
			fetch = function (rec, cb) {
				//Log(">>>header", rec.ID, rec.arg0, rec.arg1, rec.arg2 );
				cb( rec.arg2.tag( "h"+rec.arg1.length, {} ) );
			},
			pattern = /^(\#+) (.*)\n/gm;
		
		//Log("Xsection", this.match( pattern ) );
		this.serial( fetch, pattern, key, html => cb(html) );
	}
	
].Extend(String);

JAX.config({		// for blogging
	MathJax: {
		tex2jax: {
			//displayMath: [["$$","$$"]]
		}
	}
});
JAX.start();

Start("blog");

// UNCLASSIFIED
