// UNCLASSIFIED

// nodejs modules
const		
	ENV = process.env,
	{ readFile, readFileSync } = require("fs"),
	{ compile } = require('jade'),			//< using jade (now pug) as the skinner	
	{ isMaster } = require("cluster");

// totem modules
const	  
	{Each,Copy,Log,Debug,typeOf,isString,Fetch, publishPlugins,Start} = require("@totemstan/enums");

/**
Provides an endpoint to render [DEBE](https://github.com/totemstan/debe) notebooks, datasets, and 
engines using the (possibly dynamically generated) jade associated with the requested 
notebook/table/engine.  This module 
documented in accordance with [jsdoc]{@link https://jsdoc.app/}.

@module SKIN
@author [ACMESDS](https://totemstan.github.io)

@requires [enums](https://github.com/totemstan/enums)

@requires [fs](https://nodejs.org/docs/latest/api/)
@requires [cluster](https://nodejs.org/docs/latest/api/)

@requires [jade@1.9.0](https://www.npmjs.com/package/jade)

*/
const
	{Trace, renderJade, errors, skinContext, paths, lookups} = SKIN = module.exports = {
	
	Trace: (msg, ...args) => `skin>>>${msg}`.trace( args ),
		
	config: opts => {
		if (opts) Copy(opts,SKIN,".");
		
		if ( isMaster ) {
			if ( false ) publishPlugins();
			
			if ( jades = paths.jades && false )
				Fetch( jades, files => {  // publish new engines
					var ignore = {".": true, "_": true};
					files.forEach( (file) => {
						if ( !ignore[file.charAt(0)] )
							try {
								Trace("PUBLISHING", file);

								sql.query( "REPLACE INTO openv.engines SET ?", {
									Name: file.replace(".jade",""),
									Code: readFileSync( path+file, "utf-8"),
									Type: "jade",
									Enabled: 0
								});
							}
							catch (err) {
								//Log(err);
							}
					});
				});			
		}
		
		return SKIN;
	},

	publishPlugins: () => { //< publish discovered plugins
		if ( plugins = paths.plugins )
			Fetch( plugins, files => {	// get plugin names to publish
				files.forEach( file => {
					var
						[name,type] = file.split(".");

					if ( type == "js" )
						Fetch( `file:/${name}.pub`, status => {} );
				});	
			});
	},

	paths: {
		//logView: "INSERT INTO openv.dblogs SET ? ON DUPLICATE KEY UPDATE Actions=Actions+1,?",
		getSkin: "SELECT Name,Type,Enabled,Code,State FROM openv.engines WHERE least(?,1) LIMIT 1",
		//cacheSkin: "INSERT INTO openv.engines SET ?",
		jades: "./jades",		// path to default view skins
		jadeRef: "./jades/ref.jade",	// jade reference path for includes, exports, appends		
	},
		
	errors: {
		noSkin: new Error("no such skin"),
		badSkin: new Error("skin contains invalid jade"),		
		noEngine: new Error("requested engine does not exist"),
	},
	
	lookups: {},
		
	context: {	//< default skinning context
	},
		
/**
Callback cb with skinning context ctx for requested table.

@param {Object} req Totem request
@param {Function} cb callback(ctx)
*/
	skinContext: function (sql, ctx, cb) {
		
		const 
			{ table , query, flags, type, ds, name } = ctx,
			{ context } = SKIN,
			{ urls } = context,
			{ getSkin } = paths,
			verbose = type != "run";
			  
		//Log(">>>skin ctx", ctx);
		sql.query( 	// get engine info
			//"SELECT Type FROM openv.engines WHERE ? LIMIT 1", 
			getSkin, {
				Name: name,
				Type: "jade",
				Enabled: 1
			}, (err,engs) => {

			const
				eng = engs[0] || {Type: ""};

			Copy({		// prime skinning context 
				engine: eng.Type,

				/*
				Drop notebook html interface into the current skin.  As this i/f contains 
				html content itself (e.g. the html content generated for each i/f key when 
				the notebook was published), the returned i/f html needs to be escaped,
				typically using the "$with x=interface():\n\t${x}\n\n" skinning escape
				in the hosting skin.
				*/
				interface: () => {
					const
						ifs = [], 
						{ fields } = ctx;

					fields.forEach( f => {
						ifs.push({ 
							Key: f.Field, 
							Type: f.Type, 
							Details: unescape(f.Comment || "missing")
						});
					});
					return ifs.gridify();
				},

				flags: flags
			}, ctx);

			sql.query(	// get collaborators
				"SELECT group_concat(concat('<a href=\"emailto:',Client,'\">',Client,'/a>+',Actions)) AS Colabs FROM openv.dblogs WHERE Dataset=? ORDER BY Actions desc", 
				table, (err,recs) => {

				//Log("skin colab", err||recs);

				ctx.colabs = recs[0].Colabs;

				//Log(">>>>getkeys", table, type, verbose);
				sql.query( 	// get keys
					verbose
						? "SHOW FULL COLUMNS FROM ?? WHERE Type != 'timestamp' AND Type != 'geometry' "
						: "SHOW FULL COLUMNS FROM ?? WHERE Type != 'timestamp' AND Type != 'geometry' AND Field NOT LIKE 'Save%' "
					, [ds], (err,fields) => {

					//if (!verbose) Log(">>>show", ds, err, fields);
					ctx.fields = err ? null : fields;

					sql.query(	// get project info
						"SELECT * FROM openv.projects WHERE ? LIMIT 1", 
						{Name: name}, (err,projs) => {

						const proj = ctx.proj = projs[0] || { JIRA: "tbd", Status: "tbd", Name: ctx.name, Title: ctx.name, Lead: "tbd" };

						sql.query(		// get RAS/subcontractor info
							"SELECT group_concat(RAS) AS RAS FROM openv.milestones WHERE ? AND RAS", 
							{Project: ctx.name}, (err, vendors) => {

							sql.query(
								"SELECT Seq, group_concat('Q:',Q,'A:',A) AS QA FROM openv.faqs WHERE ? GROUP BY Seq",
								{Name: ctx.name}, (err, faqs) => {

								function getArtifacts( ctx, cb ) {
									Fetch( `file:/artifacts/${ctx.name}/`, files => {
										var 
											id = 1,
											Files = ctx.files = {
												deck: {},
												image: [],
												artifact: [],
												misc: [],
												live: []
											},
											Batch = {
												jpg: "image",
												png: "image",
												gif: "image",
												mpeg: "image",
												mp4: "image",
												avi: "image",
												mov: "image",
												ppt: "artifact",
												pptx: "artifact",
												txt: "artifact",
												doc: "artifact",
												pdf: "artifact",
												docx: "artifact",
												html: "live",
												default: "misc"
											};

										if ( files )
											files.forEach( file => {
												var 
													path = `.${book}/${file}`,
													parts = file.split("_"),
													num = 0,
													classif = [],
													type = "",
													title = [],
													depth = 1;

												parts.forEach( (part,n) => {
													switch (part) {
														case "":
															depth++;
															break;
														case "S":
														case "U":
														case "TS":
														case "C":
														case "FOUO":
														case "LIMDIS":
														case "NF":
														case "ORCON":
														case "FVEY":
														case "NATO":
															classif.push( part );
															break;
														default:
															if ( n = parseFloat(part) )
																num = n;

															else {
																var parts = part.split(".");
																title.push( parts[0] );
																type = (parts[1] || "").toLowerCase();
															}
													}
												});

												switch ( type ) {
													case "":
													case "rdp":
													case "url":		// discard
														break; 

													case "lnk":		// re-path it then batch it
														try {	
															readFileSync( path, "utf8" ).replace( /\&(.*)\+/, (pre,goto) => {
																path = goto.replace(".\\", "/notebooks/"); // assume local link
																//Log(">>>goto", path);
															});
														}
														catch (err) { // keep as is
														}

													default:
														var 
															set = `set${depth}`,
															stack = ( depth && num ) 
																	? Files.deck[set] || ( Files.deck[set] = [] )
																	: Files[ Batch[type] || Batch.default ];

														//Log(title, type, depth, num, set, stack.constructor);
														stack.push( {
															id: id++,
															num: num, 
															title: title.join(" "), 
															classif: ("(" + classif.join("//") + ")").replace("()","(U)"),
															type: type, 
															name: file, 
															parts: parts.length-1, 
															path: path, 
															link: title[0].link( path ) 
														} );
													}
											});

										Each( Files.deck, (set,files) => Files.deck[set] = files.sort( (a,b) => a.num-b.num ) );

										//Log("file ctx", Files);

										cb(ctx);
									});
								}

								function getDatasets( ctx, cb ) {
									const
										data = ctx.data = {};

									Fetch( `file:/artifacts/${ctx.name}/data/`, files => {
										if ( files ) {
											var
												toRead = files.length,
												read = 0;

											files.forEach( file => {
												const
													path = `.${book}/${file}`,
													[x,name,type] = file.match( /(.*)\.(.*)/ ) || [file,""];

												//Log(">>>>>>>>>>>>>>>reading", name,type);
												switch ( type ) {
													case "xslx":
													case "csv":
														if ( ++read == toRead ) cb(ctx);
														break;

													case "js":
														CP.exec(`node ${path}`, (err,log) => {
															data[name] = err || log;
															if (++read == toRead) cb(ctx);
														});
														break

													case "py":
														CP.exec(`python ${path}`, (err,log) => {
															data[name] = err || log;
															if (++read == toRead) cb(ctx);
														});
														break

													case "url":
														const
															[x,pre,url] = readFileSync( path, "utf8" ).match( /(.*)URL=(.*)\r\n/ );

														//Log(" >>>>>url read=", {txt: readFileSync( path, "utf8" ), url:url} );

														if ( url ) 
															Fetch(url, txt => {
																data[name] = txt;
																if ( ++read == toRead ) cb(ctx);
															});

														else
														if ( ++read == toRead ) cb(ctx);

														break;

													default:
														data[name] = readFileSync( path, "utf8" );
														if ( ++read == toRead ) cb(ctx);
												}
											});

											if ( !toRead ) cb(ctx);
										}
										
										else
											cb(ctx);
									});
								}

								const vendor = vendors[0] || { RAS: "none" };

								proj.RAS = vendor.RAS || "none";

								// Log(">proj", proj);
								getArtifacts( ctx, ctx => {
									const 
										{table,engine,host} = ctx;

	//Log(">>>>>>>>>>>> env host", host, domain);
	//Log(">>>>>>>>>>>>>>repo", context.repo, `${context.repo}/artifacts/tree/master/${name}` );								
									const 
										name = table,
										Name = name.toUpperCase(),
										book = "/" + name,
										urls = {
											_exe: `/${name}.exe?name=CASE`,
											_run: `/${name}.run`,
											_view: `/${name}.view`,
											_tou: `/${name}.tou`,
											_publish: `/${name}.pub` ,
											_export: `/${name}.export`,
											_import: `/${name}.import`,
											_artifacts: `/explore.view?src=/root/artifacts/${name}/`,
											_brief: `/brief.view?_project=${name}`,
											_clone: `/${name}.${ctx.engine}`,
											_repo: `${context.REPO}/artifacts/tree/master/${name}`,
											_jira: `${context.JIRA}/project=${proj.JIRA}`,										
											_ras: `${context.RAS}/project=${proj.RAS}`,
											_rtp: `/rtpsqd.view?_project=${name}`,
											_reset: `${name}.reset`,
											_repofiles: `${context.repo}/${name}/raw/master`,
											_relinfo: `/releases.html?nb=${name}`
										},
										links = {};

									Object.keys(urls).forEach( _key => links[_key] = _key.substr(1).link( urls[_key] ));

	//Log("=======skin ref=", referer);

									Copy(urls, Copy(context, Copy({
										Name: Name,

										faqs: faqs,

										register: () => 
											"<!---parms endservice=https://myservice/" + ctx.name + "--->" 
											+ ctx.input({a:"aTest", b:"bTest"}),

										//input: tags => "<!---parms " + "".tag("&", tags || {}).substr(1) + "--->",

										summary: "summary tbd",
										ver: "ver tbd",
										reqs: {
											distrib: "request to distribute NAME/Can you grant permission to distribute NAME?".replace(/NAME/g, Name),
											info: "request for information on NAME/Can you provide further information on NAME?".replace(/NAME/g, Name),
											help: "need help on NAME/Please provde me some help on notebook NAME".replace(/NAME/g, Name)
										},
										request: req => {
											var
												parts = (req || ctx.reqs.info || "request/need information").split("/"),
												label = parts[0] || "request",
												body = parts[1] || "request for information",
												pocs = ctx.pocs || {};

											//Log("pocs", pocs, label, body, name, req);
											return (pocs.admin||"").mailify( label, {subject: name, body: body} );
										},

										//interface: () => "publish notebook to define interface",
										now: (new Date()).toUTCString(),

										//loopback: host + "." + engine +"?endservice=" + host +".users",
										//transfer: host + "." + engine + "?endservice=",
										//totem: host,
										//api: host + "/api.view",

										uses: Object.keys(links).map( _key => links[_key] ).join(" || "),

										// windows ie
										// "file://164.183.33.7/totem/notebooks/" + name,
										// windows ff
										// "file://///164.183.33.7/totem/notebooks/" + name,
										// linux
										//"file://local/service/debe/notebooks/" + name,

										//brief: "/brief.view?notebook=" + name,
										//rtp: "/rtpsqd.view?notebook=" + name,

									}, ctx)));

									// Log(">arts", Path,envs);
									Object.keys(urls).forEach( _key => {	// mutate urls
										const 
											url = ctx[_key],
											key = _key.substr(1),
											Key = key.charAt(0).toUpperCase()+key.substr(1),
											KEY = key.toUpperCase(),
											$Key = "$"+Key,
											$key = "$"+key,
											$KEY = "$"+KEY;

										ctx[$KEY] = `$embed{${url}}`;
										ctx[$Key] = Key.link( url );
										ctx[$key] = key.link( url );
									});

									getDatasets(ctx, ctx => {
										cb(ctx);
									});
								});
							});
						});
					});
				});				
			});
		});	
	},
	
/**
Render jade string to callback cb( err || html ) in a new context created for 
this request. 

@param {String} jade contents to render
@param {Object} ctx skinning context
@param {Function} cb callback(ctx)
**/
	renderJade: function ( jade, ctx, cb ) { 
		ctx.skin = jade;				// forgot who needs this
		ctx.filename = paths.jadeRef;	// jade compiler need to resolve extends

//Trace("render jade", ctx);
		//Log("files", ctx.files.deck.set1.map( file => [file.num, file.title] ));
		
		try {
			//jade.Xblog( ctx, jade => cb( compile(jade, ctx) (ctx) ) );			
			
			cb( compile(jade, ctx) (ctx) );	
			
			//(compile(jade, ctx) (ctx)).Xblog( ctx, html => cb(html) );
			
			//(compile(jade, ctx) (ctx)).Xinclude( "", html => cb(html) );
			//(compile(jade, ctx) (ctx)).Xinclude( "", html => html.Xfollow( "", ctx, html => cb(html) ) );
			//jade.Xkeys( ctx, jade => cb( compile( jade, ctx)(ctx) ) );
			//jade.Xkeys( ctx, jade => (compile( jade, ctx)(ctx)).Xinclude( "", html => cb(html) )  );
			//jade.Xinclude( "", ctx, jade => cb( compile(jade, ctx) (ctx) ) );
			//(compile(jade, ctx) (ctx)).Xiframe( "", html => cb(html) );
		}
		
		catch (err) {
			//Log("render jade", err);
			cb( err+"" );
		}
	},
	
/**
Endpoint to render req.table using associated jade engine. 

@param {Object} req Totem request
@param {Function} res Totem response
*/
	renderSkin: function (req,res) {
		function renderFile( file, ctx, cb ) { 

//Trace("skin render file", file);
			readFile( file, "utf-8", (err,jade) => {
				if (err) 
					cb( errors.noSkin );

				else {
					const 
						{table,opts} = ctx,
						{cacheSkin} = paths;
					
					if (cacheSkin)
						sql.query( cacheSkin, {
							Name: table,
							Type: "jade",
							Code: jade,
							Enabled: true,
							Client: "totem",
							State: opts ? JSON.stringify(opts) : null
						});

					renderJade( jade, ctx, cb );
				}
			})
		}

		/*
		Render Jade file at path this to res( err || html ) in a new context created for this request.  
		*/
		function tableCols( fields ) { // render table using jade plugin

			const 
				cols = [],
				quals = { ID:"hide", id:"hide", timestamp: "drop", geometry: "drop" },
				saver = "Save",
				grouper = "_";

			switch ( typeOf(fields) ) {
				case "Array":	
					fields.forEach( field => {
						var 
							Key = field.Field, 
							Type = field.Type.split("(")[0],
							Tip = field.Comment || "",
							Qual = quals[Key] || ""; 
// Log(">>>>skin", Key, Type, Qual);

						if ( !Qual ) {
							if ( select = lookups[Key] ) {
								Type = "select"; 
								Qual = select; 
							}

							else
							if ( Key.startsWith(saver) )
								Qual = "lock"; 

							else
							if ( Key.startsWith(grouper) ) 
								Qual = "lock";
						}
						
						if ( Qual != "drop" )
							cols.push( Key + "." + Type + "." + Tip + "." + Qual );
					});

					break;

				case "String":
					fields.split(",").forEach( field => {
						if ( field != "ID") cols.push( field );
					});	
					break;

				default:
					Each(fields, field => {
						if (field != "ID") cols.push( field );
					});	
			}

			return cols.groupify(grouper);
		}

		const
			{sql,path,table,url,now,client,flags,type,query,referer,site,ds,profile} = req,
			ctx = Copy(site, {
				//name: ds.split(".")[1]
				query: query,
				table: table,
				flags: flags,
				type: type,
				client: client,
				ds: ds,
				url: url,
				profile: profile,
				$referer: referer,
				name: flags.project || table
			});
		
		skinContext(sql, ctx, ctx => {
//Trace("get ctx", ctx);
			
			if (ctx) { // render skin
				const 
					{name,type,fields,flags,query} = ctx,
					{logView,getSkin } = paths;
				
				//Log("skin check", name,table,type, flags, "isTable=", fields?true:false);
				
				if (logView)
					sql.query( logView, [{
						Op: "view",
						Event: now,
						Dataset: (name==table) ? table : name,
						Client: client
					}, {
						Event: now
					}]);

				sql.query( getSkin, { 		// look for skinning engine
					Name: table,
					Type: "jade",
					Enabled: 1
				}, (err,engs) => {

					if ( eng = engs[0] ) {	// render using cached jade engine
						ctx.opts = eng.State ? eng.State.parseJSON({
							ds: table,
							mode: type,
							cols: "",
							query: query
						}) : null;
						renderJade( eng.Code || "", ctx, html => res(html) );
					}

					else 					// render using file then update engine cache						
						if ( fields ) {		// render plugin/notebook table
							ctx.opts = {
								ds: table,
								mode: type,
								cols: tableCols( fields ),
								query: query
							};
							renderFile( `${paths.jades}/plugin.jade`, ctx, html => res(html) );
						}

						else { 				// render jade file
							ctx.opts = null;
							renderFile( `${paths.jades}/${table}.jade`, ctx, html => res(html) );	
						}
				});
			}
			
			else
				res( errors.noEngine );
		});
	}
};

Start("skin");

// UNCLASSIFIED
